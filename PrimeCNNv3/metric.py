# AUTOGENERATED! DO NOT EDIT! File to edit: 05_metrics.ipynb (unless otherwise specified).

__all__ = ['accuracy', 'balance_accuracy', 'error_rate', 'precision', 'recall', 'f1score', 'f1beta', 'confusion_matrix',
           'plot_confusion_matrix', 'accuracy_multi', 'f1score_multi', 'precision_multi', 'recall_multi']

# Cell
from .imports import *
from sklearn.metrics import precision_score, recall_score, f1_score, fbeta_score, balanced_accuracy_score
from sklearn.metrics import confusion_matrix as cm
import seaborn as sns

# Cell
def accuracy(preds, target, dim = -1, index = True):
    '''
        Returns accuracy

        Args:
        if index is True
        preds (torch_tensor): prediction of the model
        target (torch): target values
        dim: dimention to use
    '''
    if not index:
        return (preds == target).float().mean().item()
    return (preds.argmax(dim = dim) == target).float().mean().item()

# Cell
def balance_accuracy(preds, target, dim = -1, average = 'macro', index = True, **kwargs):
    if not index:
        return balanced_accuracy_score(y_pred=preds.numpy(), y_true = target.numpy(), average=average, **kwargs)
    return balanced_accuracy_score(y_pred=preds.argmax(dim = dim).numpy(), y_true = target.numpy(), average=average, **kwargs)

# Cell
def error_rate(preds, target, dim = -1, index = True):
    '''
        Returns error_rate
        1- accuracy

        Args:
        preds (torch tensor): prediction of the model
        target (torch tensor): target values
        dim: dimention to use
    '''
    return 1 - accuracy(preds=preds, target = target, dim = dim, index = index)

# Cell
def precision(preds, target, dim = -1, average = 'macro',index = True, **kwargs):
    '''Global average precision score'''
    if not index:
        return precision_score(y_pred=preds.numpy(), y_true = target.numpy(), average=average, **kwargs)
    return precision_score(y_pred=preds.argmax(dim = dim).numpy(), y_true = target.numpy(), average=average, **kwargs)

# Cell
def recall(preds, target, dim = -1,average = 'macro',index = True, **kwargs):
    if not index:
        return recall_score(y_pred=preds.numpy(), y_true = target.numpy(), average=average, **kwargs)
    return recall_score(y_pred=preds.argmax(dim = dim).numpy(), y_true = target.numpy(), average=average, **kwargs)

# Cell
def f1score(preds, target, dim = -1, average = 'macro', index = True, **kwargs):
    if not index:
        return f1_score(y_pred=preds.numpy(), y_true = target.numpy(), average=average, **kwargs)
    return f1_score(y_pred=preds.argmax(dim = dim).numpy(), y_true = target.numpy(), average=average, **kwargs)

# Cell
def f1beta(beta, preds, target, dim = -1, average = 'macro', index = True, **kwargs):
    if not index:
        return fbeta_score(beta = beta, y_pred=preds.numpy(), y_true = target.numpy(), average=average, **kwargs)
    return fbeta_score(beta = beta, y_pred=preds.argmax(dim = dim).numpy(), y_true = target.numpy(), average=average, **kwargs)

# Cell
def confusion_matrix(preds, target, labels = None, **kwargs):
    return cm(y_pred=preds, y_true=target,**kwargs)


# Cell
def plot_confusion_matrix(preds, target, labels = None, **kwargs):
    sns.heatmap(cm(y_pred=preds, y_true=target), annot = True, cmap="Blues", fmt='d', xticklabels=labels,yticklabels=labels, cbar = False )
    plt.xlabel('Predicted')
    plt.ylabel('Target')

# Cell
def accuracy_multi(preds, target, threshold = 0.5, sigmoid = True):
    '''
        Returns accuracy

        Args:
        if index is True
        preds (torch_tensor): prediction of the model
        target (torch): target values
        dim: dimention to use
    '''
    if sigmoid:
        preds = torch.sigmoid(preds)
    return ((preds > threshold) == target).float().mean().item()

# Cell
def f1score_multi(preds, target, threshold = 0.5, average = 'macro', sigmoid = True, **kwargs):
    if sigmoid:
        preds = torch.sigmoid(preds)
    return f1_score(y_pred=(preds>threshold).numpy(), y_true = target.numpy(), average=average, **kwargs)

# Cell
def precision_multi(preds, target, threshold = 0.5, average = 'macro', sigmoid = True, **kwargs):
    if sigmoid:
        preds = torch.sigmoid(preds)
    return precision_score(y_pred=(preds>threshold).numpy(), y_true = target.numpy(), average=average, **kwargs)

# Cell
def recall_multi(preds, target, threshold = 0.5, average = 'macro', sigmoid = True, **kwargs):
    if sigmoid:
        preds = torch.sigmoid(preds)
    return recall_score(y_pred=(preds>threshold).numpy(), y_true = target.numpy(), average=average, **kwargs)