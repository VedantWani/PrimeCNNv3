# AUTOGENERATED! DO NOT EDIT! File to edit: 06_NIA.PSO.ipynb (unless otherwise specified).

__all__ = ['Particle', 'PSO', 'random_weight']

# Cell
from ..imports import *

# Cell

class Particle:
    pass

# Cell
class PSO:
    def __init__(self,c1,c2,weight_func,population, fitness_eval_func, n_dims, dim_limits):

        self.population = population
        self.fitness_eval_func = fitness_eval_func
        self.n_dims = n_dims
        self.dim_limits = dim_limits
        self.best_solutions = []
        self.weight_func = weight_func #weight is is function to adopt random intertia weight
        self.c1 = c1
        self.c2 = c2
        self.gbest = Particle()
        self.gbest.fitness = float('-inf') #maximize
        self.Swarm = []

    def _initialize_population(self):
        for solution in range(self.population):
            start = 0
            particle = Particle()
            particle.position = np.array([])
            particle.velocity = np.array([])
            for end in self.dim_limits:

                pos_vec = np.random.uniform(*self.dim_limits[end], (end-start))
                velocity_vec = np.random.uniform(*self.dim_limits[end], (end-start))

                particle.position = np.concatenate((particle.position, pos_vec))
                particle.velocity = np.concatenate((particle.velocity, velocity_vec))

                start = end

            particle.fitness = self.fitness_eval_func(particle.position)

            particle.best_position = particle.position
            particle.best_fitness = particle.fitness

            if self.gbest.fitness < particle.best_fitness:
                self.gbest.fitness = particle.best_fitness
                self.gbest.position = particle.best_position


            self.Swarm.append(particle)

        self.best_solutions.append(self.gbest)

    def optimize(self):

        for particle in self.Swarm:
            cognitive = self.c1 * np.random.rand(self.n_dims) * (particle.best_position - particle.position)
            social = self.c2 * np.random.rand(self.n_dims) * (self.gbest.position - particle.position)
            particle.velocity = self.weight_func() * particle.velocity + cognitive + social
            particle.position = particle.position + particle.velocity

            particle.position = self._constraint_solutions(particle.position)

            particle.fitness = self.fitness_eval_func(particle.position)

            if particle.best_fitness < particle.fitness:
                particle.best_fitness = particle.fitness
                particle.best_position = particle.position

            if self.gbest.fitness < particle.best_fitness:
                self.gbest.fitness = particle.best_fitness
                self.gbest.postion = particle.best_position

        self.best_solutions.append(self.gbest)

    def _constraint_solutions(self, position):
        start = 0
        for end in self.dim_limits:
            position[start:end] = np.maximum(position[start:end], self.dim_limits[end][0]) #minimum limit
            position[start:end] = np.minimum(position[start:end], self.dim_limits[end][1]) # maximum limit

            start = end

        return position

# Cell
def random_weight():
    return 0.5 * (np.random.rand() / 2)